#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;
const int maxn=1005;
ll s[maxn][maxn];
ll sum=1;
void c()
{
	for(int i=0;i<=1000;i++)
	{
		s[i][0]=s[i][i]=1;
		for(int j=1;j<i;j++)
			s[i][j]=s[i-1][j-1]+s[i-1][j];
	}
}
int main()
{
	c();
	int n,k,a[]={0,0,1,2,9};
	cin>>n>>k;
	for(int i=2;i<=k;i++)
	{
			sum+=s[n][i]*a[i];
	}
	cout<<sum<<endl;
	return 0;
}

题意：
     对于一个1～n的序列，给定一个K，如果它的全排列中某一个排列，它至少有b-k个 Pi=i，求满足要求字串的数目

分析：
     观察到1<=k<=4，采用枚举  还有能确定的一点是肯定是排列组合  但是纵观  排列  和  组合  公式又不能满足我们的需求。通过查找博客我发现了一个错排的组合公式这是组合数学的一个问题。一个简单的问题理解错排 过年了，有四个人各自写了一张贺卡要送给别人，问有多少种赠送方法，并且自己不能拿到自己的贺卡。

引入错排公式 D(n)=(n-1)[D(n-2)+D(n-1)] 

错排公式推倒方法

情景 有N个小球 将它们排序 要求他们的编号不能和位置序号不能相同

第一步 取出来第N个小球摆放到一个位置 比如位置K 一共有n-1方法

第二步 要考虑编号为K的元素 这是有两种情况(1) 把它放在位置N 剩下N-2个元素就有D(n-2)种方法（2）不把K放在位置N 这时有D(n-1)种方法

特殊的 D(1)=0 ,D(2)=1,

可以递推出 D(3)=2 D(4)=9

到此为止第一个问题解决  但不是最后一个问题，因为问题范围为1000 当数据量较大时 算排列公式时会出现超出范围的情况 不得不想办法来优化组合公式

查了资料发现 组合公式竟然可以用 递推来做 附上源码

long long c[1005][1005];
void calc_Cmn()
{
	for(int i=0;i<1001;i++)
	{
		c[i][0]=c[i][i]=1;
		for(int j=1;j<i;j++)
		{
			c[i][j]=c[i-1][j-1]+c[i-1][j];
		}
	}
	return ;
}

总结来说递推式如下  c(n,m)=c(n-1,m-1)+c(n-1,m)
右边可以理解为 在n个备选元素中的某一个元素未特殊元素。从n中选m个元素可以分为 包不包括这个特殊元素

至此 总结 整体思路  因为有至少 所以要1～k到要计算 每次先选择 出来 需要错排的元素 （用到组合公式）将元素错排 相加即可  最重要的一点要初始化 sum为1
